import { readdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import matter from "front-matter";

const scriptFilePath = fileURLToPath(import.meta.url);
const scriptDir = path.dirname(scriptFilePath);
const webDir = path.resolve(scriptDir, "..");
const repoRoot = path.resolve(webDir, "..");
const docsRoot = path.join(webDir, "src", "pages", "docs");
const outputPath = path.join(webDir, "LLMS.txt");

const ignoredDirectories = new Set([
  ".git",
  ".astro",
  ".next",
  ".turbo",
  "coverage",
  "dist",
  "build",
  "node_modules",
]);

const ignoredFiles = new Set(["AGENTS.md"]);

async function walkMarkdownFiles(dir) {
  const entries = await readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    if (entry.name.startsWith(".")) {
      continue;
    }

    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (ignoredDirectories.has(entry.name)) {
        continue;
      }

      files.push(...(await walkMarkdownFiles(fullPath)));
      continue;
    }

    if (!entry.isFile() || !entry.name.endsWith(".md")) {
      continue;
    }

    if (ignoredFiles.has(entry.name)) {
      continue;
    }

    if (path.resolve(fullPath) === outputPath) {
      continue;
    }

    files.push(fullPath);
  }

  return files;
}

function normalizePathForOutput(filePath) {
  return path.relative(repoRoot, filePath).split(path.sep).join("/");
}

function extractFirstHeading(content) {
  const headingMatch = content.match(/^#{1,6}\s+(.+)$/m);
  return headingMatch ? headingMatch[1].trim() : null;
}

function formatMetadata(attributes) {
  const entries = Object.entries(attributes);
  if (entries.length === 0) {
    return "none";
  }

  return entries
    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)
    .join(", ");
}

async function buildLlmsContent() {
  const markdownFiles = (await walkMarkdownFiles(docsRoot)).sort((a, b) =>
    normalizePathForOutput(a).localeCompare(normalizePathForOutput(b)),
  );

  const sections = [];

  for (const markdownFile of markdownFiles) {
    const raw = await readFile(markdownFile, "utf8");
    const parsed = matter(raw);
    const body = parsed.body.trim();
    const relPath = normalizePathForOutput(markdownFile);
    const fallbackTitle = extractFirstHeading(parsed.body) ?? path.basename(markdownFile, ".md");
    const titleValue = parsed.attributes.title;
    const title = typeof titleValue === "string" && titleValue.trim().length > 0 ? titleValue.trim() : fallbackTitle;

    const sectionLines = [
      `## ${title}`,
      `File: ${relPath}`,
      `Metadata: ${formatMetadata(parsed.attributes)}`,
      "",
      body.length > 0 ? body : "(No body content)",
      "",
      "---",
      "",
    ];

    sections.push(sectionLines.join("\n"));
  }

  const header = [
    "# OpenGameInstaller LLMS Bundle",
    "",
    "This file is auto-generated by web/scripts/generate-llms.mjs.",
    "Do not edit this file manually.",
    `Generated: ${new Date().toISOString()}`,
    `Source markdown files: ${markdownFiles.length}`,
    "",
    "Included files:",
    ...markdownFiles.map((markdownFile) => `- ${normalizePathForOutput(markdownFile)}`),
    "",
    "=== BEGIN DOCUMENTATION ===",
    "",
  ].join("\n");

  return `${header}${sections.join("")}`;
}

export async function generateLlmsBundle() {
  const content = await buildLlmsContent();
  await writeFile(outputPath, content, "utf8");
  return normalizePathForOutput(outputPath);
}

if (process.argv[1] && path.resolve(process.argv[1]) === scriptFilePath) {
  const generatedPath = await generateLlmsBundle();
  console.log(`Generated ${generatedPath}`);
}
